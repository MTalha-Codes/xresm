use std::io::BufRead;
use std::process::Command;
/// # Resolution Manager
/// This struct is the backbone of whole project, and it decides how the resolution is handled.
/// ## Fields
/// This struct has two fields for storing:
///    - Width of the Resolution that a user want to apply.
///    - Height of the Resolution that a user want to apply.
///
///   Both fields are of type `String`
/// ## Methods
/// This struct handles resolution management via a number public and private methods.
/// Encapsulation is embraced by keeping some methods private.
pub struct ResolutionManager {
    desired_resolution_width: u32,  // entered by user
    desired_resolution_height: u32, // entered by user
}

// Implementation of Resolution Manger struct.
impl ResolutionManager {
    /// ## The `new()` Method
    /// It initializes the struct's fields with actual `width` and `height` provided by the user.
    /// ## Parameters
    /// It takes two parameters.
    /// 1. `width: u32`: An unsigned integer representing Width of required resolution.
    /// 2. `height: u32`: An unsigned integer representing Height of required resolution.
    /// ## Returns
    /// It returns a `Self` object; or in simple words initialized version of the Struct.
    pub fn new(width: u32, height: u32) -> Self {
        ResolutionManager {
            desired_resolution_height: height,
            desired_resolution_width: width,
        }
    }
    /// ## The `is_xrandr_installed()` Method
    /// It figures out whether `xrandr` is installed on your system or not.
    /// ## Parameters
    /// It takes one implicit parameter.
    /// - `&self`: An Immutable reference to the struct.
    /// ## Returns
    /// It returns a tuple of type `(bool, &str)`; where
    /// - `bool` is either false or true depending on returned value by the command.
    /// - `&str` is custom curated error message
    fn is_xrandr_installed(&self) -> (bool, &str) {
        (
            Command::new("xrandr").arg("--help").output().is_ok(),
            "xrandr not installed on your system",
        )
    }
    /// ## The `is_cvt_installed()` Method
    /// It figures out whether `cvt` is installed on your system or not.
    /// ## Parameters
    /// It takes one implicit parameter.
    /// - `&self`: An Immutable reference to the struct.
    /// ## Returns
    /// It returns a tuple of type `(bool, &str)`; where
    /// - `bool` is either false or true depending on returned value by the command.
    /// - `&str` is custom curated error message
    fn is_cvt_installed(&self) -> (bool, &str) {
        (
            Command::new("cvt").arg("--help").output().is_ok(),
            "cvt not installed on your system",
        )
    }
    /// ## The `get_mode_line()` Method
    /// It executes `cvt width height` command anonymously in the terminal where width and height are the fields of the struct.
    /// ## Parameters
    /// It takes one implicit parameter.
    /// - `&self`: An Immutable reference to the struct.
    /// ## Returns
    /// It returns the modeline generated by cvt
    /// ### Example
    /// ```
    /// $ cvt 1680 1050
    /// 1680x1050 59.95 Hz (CVT 1.76MA) hsync: 65.29 kHz; pclk: 146.25 MHz
    /// Modeline "1680x1050_60.00"  146.25  1680 1784 1960 2240  1050 1053 1059 1089 -hsync +vsync
    /// ```
    /// **This is returned by the function ("1680x1050_60.00"  146.25  1680 1784 1960 2240  1050 1053 1059 1089 -hsync +vsync).**
    fn get_mode_line(&self) -> String {
        {
            let cvt_status = self.is_cvt_installed();
            if !cvt_status.0 {
                println!(
                    "cvt is not installed on your system !\nError: {}",
                    cvt_status.1
                );
                return String::new(); // return early with an empty string;
            }
        }
        let cvt_modeline = String::from_utf8(
            Command::new("cvt")
                .arg(self.desired_resolution_width.to_string())
                .arg(self.desired_resolution_height.to_string())
                .output()
                .expect("couldn't run cvt")
                .stdout,
        )
        .unwrap();
        let double_quote_index = cvt_modeline.find('"').unwrap_or(0);
        String::from(&cvt_modeline[double_quote_index..cvt_modeline.len() - 1])
    }
    /// ## The `get_output_source()` Method
    /// It executes `xrandr` anonymously in the terminal and get the output source aka connected device/display.
    /// ## Parameters
    /// It takes one implicit parameter.
    /// - `&self`: An Immutable reference to the struct.
    /// ## Returns
    /// It returns the connected display name.
    /// ### Example
    /// ```
    /// $ xrandr
    /// Screen 0: minimum 320 x 200, current 1680 x 1050, maximum 16384 x 16384
    /// VGA-1 connected primary 1680x1050+0+0 (normal left inverted right x axis y axis) 0mm x 0mm
    ///    1024x768      60.00  
    ///    800x600       60.32    56.25  
    ///    848x480       60.00  
    ///    640x480       59.94  
    ///    "1680x1050_60.00"  59.95*
    /// HDMI-1 disconnected (normal left inverted right x axis y axis)
    /// DP-1 disconnected (normal left inverted right x axis y axis)
    /// ```
    /// **from this huge output it filters and return VGA-1 which we can see is connected display.**
    fn get_connected_devices(&self) -> Vec<String> {
        {
            let xrandr_status = self.is_xrandr_installed();
            if !xrandr_status.0 {
                println!(
                    "xrandr is not installed on your system !\nError: {}",
                    xrandr_status.1
                );
                return vec!["".to_string()];
            }
        }
        // take the output of xrandr into this variable; not print to regular stdout
        let binding = Command::new("xrandr")
            .output()
            .expect("xrandr failed to run");
        let xrandr_stdout = binding.stdout.lines();
        let mut connected_devices: Vec<String> = Vec::new();
        for each_line in xrandr_stdout {
            let Ok(unwrapped_line) = each_line else {
                continue;
            };
            let Some(connected_index) = unwrapped_line.find("connected") else {
                continue;
            };
            let device = unwrapped_line[..connected_index].trim();
            if device.contains("dis") {
                continue;
            }
            connected_devices.push(device.to_string());
        }
        connected_devices
    }
    /// ## The `new_mode()` Method
    /// It executes this command anonymously in the terminal
    /// ```
    /// $ xrandr --newmode <mode_name> <clock MHz> ...
    /// ```
    /// ## Parameters
    /// It takes two parameters:
    /// 1. `&self`: Immutable reference to struct.
    /// 2. `parsed_modeline: Vec<&str>`: A vector of string slices which contains every argument needed for `--newmode` flag.
    /// ## Returns
    /// It returns `bool` to indicate whether command execution was successful or error-full.
    fn new_mode(&self, parsed_modeline: Vec<&str>) -> bool {
        Command::new("xrandr")
            .args([
                "--newmode",
                parsed_modeline[0],
                parsed_modeline[1],
                parsed_modeline[2],
                parsed_modeline[3],
                parsed_modeline[4],
                parsed_modeline[5],
                parsed_modeline[6],
                parsed_modeline[7],
                parsed_modeline[8],
                parsed_modeline[9],
                parsed_modeline[10],
                parsed_modeline[11],
            ])
            .output()
            .is_ok()
    }
    /// ## The `add_mode()` Method
    /// It executes this command anonymously in the terminal:
    /// ```
    /// $ xrandr --addmode <output> <mode_name>
    /// ```
    /// ## Parameters
    /// It takes 3 parameters:
    /// 1. `&self`: Immutable reference to struct.
    /// 2. `source: &str`: A string slice which represent the currently connected display device.
    /// 3. `mode: &str`: A string slice which represent the mode name which was added via the `xrandr --newmode` command.
    /// ## Returns
    /// It returns `bool` to indicate whether command execution was successful or error-full.
    fn add_mode(&self, source: &str, mode: &str) -> bool {
        Command::new("xrandr")
            .args(["--addmode", source, mode])
            .output()
            .is_ok()
    }
    /// ## The `apply()` Method
    /// It executes this command anonymously in the terminal:
    /// ```
    /// $ xrandr --output <output> --mode <mode_name>
    /// ```
    /// ## Parameters
    /// It takes 3 parameters:
    /// 1. `&self`: Immutable reference to struct.
    /// 2. `source: &str`: A string slice which represent the currently connected display device.
    /// 3. `mode: &str`: A string slice which represent the mode name which was added via the `xrandr --addmode` command.
    /// ## Returns
    /// It returns `bool` to indicate whether command execution was successful or error-full.
    fn apply(&self, source: &str, mode: &str) -> bool {
        Command::new("xrandr")
            .args(["--output", source, "--mode", mode])
            .output()
            .is_ok()
    }
    /// ## The `apply_resolution()` Method
    /// It handles the main resolution handling by calling different methods defined above.
    /// ## Parameters
    /// It takes only one parameter which is an immutable reference to the struct.
    /// ## Returns
    /// It returns nothing.
    pub fn apply_resolution(&self) {
        // This will not be persistent; changes will be roll backed by OS after logout or reboot.
        let connected_devices = self.get_connected_devices();
        let modeline = self.get_mode_line();
        if connected_devices.is_empty() || modeline.is_empty() {
            return; // early return to escape and not execute the remaining code; because it will lead to bad commands.
        }
        let mode = &modeline[modeline.find('"').expect("mode line is bad")
            ..modeline.rfind('"').expect("mode line is bad") + 1];
        self.new_mode(modeline.split_whitespace().collect());
        for device in connected_devices {
            let success = self.add_mode(device.as_str(), mode) && self.apply(device.as_str(), mode);
            if !success {
                println!(
                    "Failed to Set Desired Resolution\nError While Applying {}x{}",
                    self.desired_resolution_width, self.desired_resolution_height
                );
                break;
            }
        }
    }
}
