use std::process::{Command, Stdio};
/// # Resolution Manager
/// This struct is the backbone of whole project, and it decides how the resolution is handled.
/// ## Fields
/// This struct has two fields for storing: 
///    - Width of the Resolution that a user want to apply.
///    - Height of the Resolution that a user want to apply.
/// 
///   Both fields are of type `String`
/// ## Methods
/// This struct handles resolution management via a number public and private methods.
/// Encapsulation is embraced by keeping some methods private.
pub struct ResolutionManager {
    desired_resolution_width: u32,  // entered by user
    desired_resolution_height: u32, // entered by user
}

// Implementation of Resolution Manger struct.
impl ResolutionManager {
    /// ## The `new()` Method
    /// It initializes the struct's fields with actual `width` and `height` provided by the user.
    /// ## Parameters
    /// It takes two parameters.
    /// 1. `width: u32`: An unsigned integer representing Width of required resolution.
    /// 2. `height: u32`: An unsigned integer representing Height of required resolution.
    /// ## Returns
    /// It returns a `Self` object; or in simple words initialized version of the Struct.
    pub fn new(width: u32, height: u32) -> Self {
        ResolutionManager {
            desired_resolution_height: height,
            desired_resolution_width: width,
        }
    }
    /// ## The `is_xrandr_installed()` Method
    /// It figures out whether `xrandr` is installed on your system or not.
    /// ## Parameters
    /// It takes one implicit parameter.
    /// - `&self`: An Immutable reference to the struct.
    /// ## Returns
    /// It returns a tuple of type `(bool, &str)`; where 
    /// - `bool` is either false or true depending on returned value by the command.
    /// - `&str` is custom curated error message
    fn is_xrandr_installed(&self) -> (bool, &str) {
        (
            Command::new("xrandr").arg("--help").output().is_ok(),
            "xrandr not installed on your system",
        )
    }
    /// ## The `is_cvt_installed()` Method
    /// It figures out whether `cvt` is installed on your system or not.
    /// ## Parameters
    /// It takes one implicit parameter.
    /// - `&self`: An Immutable reference to the struct.
    /// ## Returns
    /// It returns a tuple of type `(bool, &str)`; where 
    /// - `bool` is either false or true depending on returned value by the command.
    /// - `&str` is custom curated error message
    fn is_cvt_installed(&self) -> (bool, &str) {
        (
            Command::new("cvt").arg("--help").output().is_ok(),
            "cvt not installed on your system",
        )
    }
    /// ## The `get_mode_line()` Method
    /// It executes `cvt width height` command anonymously in the terminal where width and height are the fields of the struct.
    /// ## Parameters
    /// It takes one implicit parameter.
    /// - `&self`: An Immutable reference to the struct.
    /// ## Returns
    /// It returns the modeline generated by cvt
    /// ### Example
    /// ```
    /// $ cvt 1680 1050
    /// 1680x1050 59.95 Hz (CVT 1.76MA) hsync: 65.29 kHz; pclk: 146.25 MHz
    /// Modeline "1680x1050_60.00"  146.25  1680 1784 1960 2240  1050 1053 1059 1089 -hsync +vsync
    /// ```
    /// **This is returned by the function ("1680x1050_60.00"  146.25  1680 1784 1960 2240  1050 1053 1059 1089 -hsync +vsync).**
    fn get_mode_line(&self) -> String {
        {
            let cvt_status = self.is_cvt_installed();
            if !cvt_status.0 {
                println!(
                    "cvt is not installed on your system !\nError: {}",
                    cvt_status.1
                );
                return String::new(); // return early with an empty string;
            }
        }
        let cvt_modeline = String::from_utf8(
            Command::new("cvt")
                .arg(self.desired_resolution_width.to_string())
                .arg(self.desired_resolution_height.to_string())
                .output()
                .expect("couldn't run cvt")
                .stdout,
        )
        .unwrap();
        let double_quote_index = cvt_modeline.find('"').unwrap_or(0);
        String::from(&cvt_modeline[double_quote_index..cvt_modeline.len() - 1])
    }
    /// The `get_output_source()` Method
    /// It executes `xrandr` anonymously in the terminal and get the output source aka connected device/display.
    /// ## Parameters
    /// It takes one implicit parameter.
    /// - `&self`: An Immutable reference to the struct.
    /// ## Returns 
    /// It returns the connected display name.
    /// ### Example 
    /// ```
    /// $ xrandr
    /// Screen 0: minimum 320 x 200, current 1680 x 1050, maximum 16384 x 16384
    /// VGA-1 connected primary 1680x1050+0+0 (normal left inverted right x axis y axis) 0mm x 0mm
    ///    1024x768      60.00  
    ///    800x600       60.32    56.25  
    ///    848x480       60.00  
    ///    640x480       59.94  
    ///    "1680x1050_60.00"  59.95* 
    /// HDMI-1 disconnected (normal left inverted right x axis y axis)
    /// DP-1 disconnected (normal left inverted right x axis y axis)
    /// ```
    /// **from this huge output it filters and return VGA-1 which we can see is connected display.**
    fn get_output_source(&self) -> String {
        {
            let xrandr_status = self.is_xrandr_installed();
            if !xrandr_status.0 {
                println!(
                    "xrandr is not installed on your system !\nError: {}",
                    xrandr_status.1
                );
                return String::new();
            }
        }
        // take the output of xrandr into this variable; not print to regular stdout
        let xrandr_stdout = Command::new("xrandr")
            .stdout(Stdio::piped())
            .spawn()
            .expect("Failed to run xrandr; Reason: Unknown")
            .stdout
            .take()
            .expect("Couldn't access xrandr output");
        let grep = Command::new("grep")
            .args(["-w", "connected"])
            .stdin(Stdio::from(xrandr_stdout))/* feed the output of xrandr into grep for pattern matching */
            .stdout(Stdio::piped())
            .output()
            .expect("Failed to run grep; Reason: Unknown")
            .stdout;
        let source_line = String::from_utf8(grep).expect("failed to parse utf-8 byte sequence");
        let connected_index = source_line
            .find("connected")
            .expect("source is parsed incorrectly");
        String::from(&source_line[..connected_index - 1])
    }
    /// ## The `new_mode()` Method
    /// It executes this command anonymously in the terminal
    /// ```
    /// $ xrandr --newmode <mode_name> <clock MHz> ...
    /// ```
    /// ## Parameters
    /// It takes two parameters: 
    /// 1. `&self`: Immutable reference to struct.
    /// 2. `parsed_modeline: Vec<&str>`: A vector of string slices which contains every argument needed for `--newmode` flag.
    /// ## Returns
    /// It returns nothing.
    fn new_mode(&self, parsed_modeline: Vec<&str>) {
        let _ = Command::new("xrandr")
            .args([
                "--newmode",
                parsed_modeline[0],
                parsed_modeline[1],
                parsed_modeline[2],
                parsed_modeline[3],
                parsed_modeline[4],
                parsed_modeline[5],
                parsed_modeline[6],
                parsed_modeline[7],
                parsed_modeline[8],
                parsed_modeline[9],
                parsed_modeline[10],
                parsed_modeline[11],
            ])
            .status()
            .expect("newmode returned something bad");
    }
    /// ## The `add_mode()` Method
    /// It executes this command anonymously in the terminal: 
    /// ```
    /// $ xrandr --addmode <output> <mode_name>
    /// ```
    /// ## Parameters
    /// It takes 3 parameters:
    /// 1. `&self`: Immutable reference to struct.
    /// 2. `source: &str`: A string slice which represent the currently connected display device.
    /// 3. `mode: &str`: A string slice which represent the mode name which was added via the `xrandr --newmode` command.
    /// ## Returns
    /// It returns nothing.
    fn add_mode(&self, source: &str, mode: &str) {
        let _ = Command::new("xrandr")
            .args(["--addmode", source, mode])
            .status()
            .expect("addmode returned something bad");
    }
    /// ## The `apply()` Method
    /// It executes this command anonymously in the terminal: 
    /// ```
    /// $ xrandr --output <output> --mode <mode_name>
    /// ```
    /// ## Parameters
    /// It takes 3 parameters:
    /// 1. `&self`: Immutable reference to struct.
    /// 2. `source: &str`: A string slice which represent the currently connected display device.
    /// 3. `mode: &str`: A string slice which represent the mode name which was added via the `xrandr --newmode` command.
    /// ## Returns
    /// It returns nothing.
    fn apply(&self, source: &str, mode: &str) {
        let _ = Command::new("xrandr")
            .args(["--output", source, "--mode", mode])
            .status()
            .expect("output returned something bad");
    }
    /// ## The `apply_resolution()` Method
    /// It handles the main resolution handling by calling different methods defined above.
    /// ## Parameters
    /// It takes only one parameter which is an immutable reference to the struct.
    /// ## Returns 
    /// It returns nothing.
    pub fn apply_resolution(&self) {
        // This will not be persistent; changes will be roll backed by OS after logout or reboot.
        let source = self.get_output_source();
        let modeline = self.get_mode_line();
        if source.is_empty() || modeline.is_empty() {
            return; // early return to escape and not execute the remaining code; because it will lead to bad commands.
        }
        let mode = String::from(
            &modeline[modeline.find('"').expect("mode line is bad")
                ..modeline.rfind('"').expect("mode line is bad") + 1],
        );
        self.new_mode(modeline.split_whitespace().collect());
        self.add_mode(source.as_str(), mode.as_str());
        self.apply(source.as_str(), mode.as_str());
    }
}
